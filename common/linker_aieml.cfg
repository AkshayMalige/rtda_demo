[connectivity]
# Define the number of compute units (CU) for each kernel.

nk=switch_mm2s_pl:1:mm2s_switch
nk=demux_8_pl:1:demux
nk=leaky_relu_pl:2:relu,relu2
nk=leaky_splitter_pl:1:splitter
# nk=roll_concat_pl:1:roll_concat  # removed: outputs now routed directly
nk=s2mm_pl:1:s2mm_out,s2mm_dummy0,s2mm_dummy1

# --- Stream Connections ---

# Layer 0: Data and weights streamed from memory into the AIE graph for dense8x128
stream_connect=mm2s_switch.out:demux.in
stream_connect=demux.out0:ai_engine_0.layer0_in
stream_connect=demux.out1:ai_engine_0.layer0_weights

stream_connect=demux.out4:relu.bias_stream

# Feedback loop: AIE output -> leaky_relu -> splitter -> AIE input for the next layer
stream_connect=ai_engine_0.layer0_out:relu.in_stream
stream_connect=relu.out_stream:splitter.in_stream
stream_connect=splitter.out_stream_0:ai_engine_0.layer1_in_0
stream_connect=splitter.out_stream_1:ai_engine_0.layer1_in_1

# Layer 1: Weights streamed from memory into the AIE graph dense128x128
stream_connect=demux.out2:ai_engine_0.layer1_weights_0
stream_connect=demux.out3:ai_engine_0.layer1_weights_1

stream_connect=demux.out5:relu2.bias_stream

# Final output from the AIE graph is processed by a second LeakyReLU and
# written to memory (roll_concat removed)
stream_connect=ai_engine_0.layer1_out:relu2.in_stream
stream_connect=relu2.out_stream:s2mm_out.s

stream_connect=demux.out6:s2mm_dummy0.s
stream_connect=demux.out7:s2mm_dummy1.s


