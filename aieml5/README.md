# AI Engine-ML Graph: Packet-Switched Two-Layer Neural Network

This directory implements the AI Engine graph that underpins the RTDA demo's
hidden-layer cascade. It showcases how ADF packet infrastructure can be used to
move activations between kernels while keeping the dense-layer compute blocks on
pure streaming interfaces.

## Architecture Overview

- **Dense 0 ("dense1")**: 128-wide hidden layer fed from an 8-element embedding
  vector.
- **Activation**: Leaky ReLU converts the hidden activations in-place.
- **Hidden Packetisation**: `hidden_stream_to_packet_kernel` converts the
  activation stream into packets, one per cascade branch.
- **Cascade fan-out**: `pktsplit<CASCADE_LENGTH>` replicates the packets and
  delivers them to each branch in the output cascade.
- **Dense 1 ("dense2")**: `CASCADE_LENGTH` DSPLib matrix-vector kernels consume
  their portion of the hidden vector and produce the final logits.
- **Runtime parameter loading**: All dense kernels receive weights via RTP
  ports, allowing the host to swap matrices without recompiling the graph.

The packet-based hop between the Leaky ReLU and the cascade ensures each branch
receives only the portion of the hidden vector it needs while avoiding wide
fan-out stream connections.

## Directory Layout

```
├── graph.cpp                        # Instantiates `NeuralNetworkGraph`
├── graph.h                          # Graph definition with packet workflow
├── stream_to_packet.cpp/h           # Converts float stream to packets for dense0
├── hidden_stream_to_packet.cpp/h    # Packetises hidden-layer activations
├── packet_to_stream.cpp/h           # Converts packets back into float streams
├── leaky_relu.cpp/h                 # Leaky ReLU activation kernel
├── aie.cfg                          # AI Engine compiler configuration
└── Makefile                         # Build rules wrapping v++
```

## Build

The supplied `Makefile` wraps the standard build flow using `v++` with AI Engine
configuration. From this directory, compile the graph with:

```bash
make graph TARGET=hw       # or TARGET=hw_emu (default: hw)
make all                   # same as 'make graph'
```

To invoke the compiler directly:

```bash
v++ -c --mode aie --target hw graph.cpp \
    stream_to_packet.cpp hidden_stream_to_packet.cpp packet_to_stream.cpp \
    leaky_relu.cpp \
    --platform=${PLATFORM} \
    --work_dir=Work \
    --config=aie.cfg \
    --include="./" \
    --include="../common" \
    --include="../dsp_lib/L1/src/aie" \
    --include="../dsp_lib/L1/include/aie" \
    --include="../dsp_lib/L2/include/aie"
```

Both commands produce `Work/libadf.a` inside this directory.

## Data Flow Walkthrough

1. **Input embedding**: `input_data` PLIO feeds an 8-element float vector into
   `stream_to_packet_kernel`, which tags the samples with an ADF packet header.
2. **Packet routing**: A single-input `pktsplit` forwards the dense0 packet to
   `packet_to_stream_kernel`, where it becomes a float stream and enters the
   first dense layer (`dense1`).
3. **Hidden activation**: The DSPLib dense kernel produces a 128-element vector
   which flows through `k_lrelu0` for Leaky ReLU activation.
4. **Hidden-layer packet hop**: `hidden_stream_to_packet_kernel` consumes the
   Leaky ReLU output, builds `CASCADE_LENGTH` packets (one per cascade lane), and
   marks TLAST on the final element.
5. **Cascade fan-out**: `pktsplit<CASCADE_LENGTH>` inspects each packet's ID and
   forwards it to the matching `packet_to_stream_hidden_kernel` instance, which
   converts the payload back into a float stream for the downstream dense kernel
   (`dense2.inB[i]`).
6. **Output logits**: The cascade of dense kernels write their partial outputs
   into the shared output PLIO `output_data`, producing the inference result.

Throughout the flow the packets exist only on the inter-kernel hop where fan-out
is required, allowing the dense compute kernels to stay on standard stream
interfaces.

## Files and Build Instructions

The PLIO files consumed by the graph reside in the project-parent
[`../data/`](../../data) directory. They are generated by
[`data/generate_test_data.py`](../data/generate_test_data.py).
